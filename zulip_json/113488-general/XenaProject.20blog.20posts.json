[
    {
        "content": "<p>some people have expressed interest in kevin's xenaproject lean posts being posted somewhere in this zulip so that they don't miss it, so i am making this topic.</p>\n<p>use this topic for posting and discussing new and old xena blog posts.<br>\nlink to the blog: <a href=\"https://xenaproject.wordpress.com/\">https://xenaproject.wordpress.com/</a></p>",
        "id": 202807376,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593785369
    },
    {
        "content": "<p>newest post: <a href=\"https://xenaproject.wordpress.com/2020/07/03/equality-specifications-and-implementations/\">Equality, specifications, and implementations</a></p>",
        "id": 202807445,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593785403
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 202807992,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593785792
    },
    {
        "content": "<p>The blog does have an RSS feed :) . However, it might not make much sense to post blog updates to the same #rss channel as repo updates</p>",
        "id": 202808848,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593786356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/202808848\">said</a>:</p>\n<blockquote>\n<p>The blog does have an RSS feed :) . However, it might not make much sense to post blog updates to the same #rss channel as repo updates</p>\n</blockquote>\n<p>i hope that this topic will already work organically. most avid lean users likely read kevin's blog anyways, so someone will most certainly post it eventually now that there's a place for it. in addition, we can also use this topic for discussion!</p>",
        "id": 202809211,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593786558
    },
    {
        "content": "<p>Yes, this RSS question also came to my mind, but I didn't suggest it because this has a clearly distinct flavor from what we put in the rss stream.</p>",
        "id": 202809280,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593786597
    },
    {
        "content": "<p>It might be possible to use different streams for different feeds, but I don't mind this being solved by manual labor</p>",
        "id": 202809729,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593786845
    },
    {
        "content": "<p>For what it's worth, of course I don't mind what happens ultimately wrt posting here, but I've not been posting these things here myself here because for me the point of this Zulip is that it is a professional place where experts hang out and help solve Lean problems and make progress with lean and mathlib. My blog posts are just supposed to be for a general mathematical audience. I have no qualms advertising them on the Xena discord but that's full of non-experts.</p>",
        "id": 202813756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593789221
    },
    {
        "content": "<p>i think that exactly because they are for a general mathematical audience, they are of interest to the experts here. </p>\n<p>discussion on how to improve the theorem proving experience also seems to be an important part of this zulip, and for that this kind of perspective (and any related discussion) is very valuable.<br>\nafter all, judging from twitter, even plenty of people that build theorem provers read your posts (likely for that exact reason!).<br>\nbesides, as a cs person myself i found many of your posts very helpful, not only to understand how lean works, but also to gain a broader perspective in terms of how decisions in the lean design impact the people formalizing mathematics :)</p>",
        "id": 202815131,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593790120
    },
    {
        "content": "<p>(this is in part why i am in favor of this topic working organically as opposed to being run by an rss bot: if people do not deem some post from your blog interesting for this zulip, perhaps because it is entirely unrelated to lean, they will simply not post it)</p>",
        "id": 202816241,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1593790912
    },
    {
        "content": "<p>This is a very naïve and probably not well-thought-out question about the latest blog post. When we want to work with specifications in Lean, we usually use structures or type classes, right? Is the issue with using structures for reals that the API is way too big to hide in a structure?</p>",
        "id": 202818740,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1593792611
    },
    {
        "content": "<p>no, we could certainly do that</p>",
        "id": 202819667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793231
    },
    {
        "content": "<p>indeed, when we get to lean 4 I'm thinking of setting up a single structure <code>constant R : RealInterface := ...</code> that proves that there exists an implementation of \"the reals\" so that we really can get some isolation</p>",
        "id": 202819780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793310
    },
    {
        "content": "<p>but I think there are not too many times when we want a hard barrier like that</p>",
        "id": 202819860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> said:</p>\n<blockquote>\n<p>But you’ll find that it’s a real bore with Dedekind cuts, because Dedekind cuts have this annoying property that you need a convention for the cuts corresponding to rational numbers: whether to put the rational number itself into the lower or upper cut. Neither convention gives a nice definition of addition. You can’t just add the lower cuts and the upper cuts, because the sum of two irrationals can be a rational.</p>\n</blockquote>\n<p>Actually addition on dedekind cuts isn't as bad as this. You can say that a dedekind cut is just the lower set (exclusive), and then pointwise addition works just fine. The thing about multiplication is true, but you can avoid the problem by only defining positive reals</p>",
        "id": 202820115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793547
    },
    {
        "content": "<p>From  a related file I'm (serendipitously) working on, how does  <code>class conditionally_complete_linear_ordered_field (F : Type*) extends discrete_linear_ordered_field F,\n  conditionally_complete_linear_order F</code> sound as the structure?</p>",
        "id": 202820192,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1593793574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/202819780\">said</a>:</p>\n<blockquote>\n<p>indeed, when we get to lean 4 I'm thinking of setting up a single structure <code>constant R : RealInterface := ...</code> that proves that there exists an implementation of \"the reals\" so that we really can get some isolation</p>\n</blockquote>\n<p>The question is: can we do that and still use the notation <code>ℝ</code> to denote some implementation (we don't care which one). And I don't mean having <code>{ℝ : Type} [RealInterface  ℝ] (x y z :  ℝ)</code></p>",
        "id": 202820420,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593793710
    },
    {
        "content": "<p>The idea would be that <code>R</code> there is now a bundled type + real axioms, and so we would define <code>def ℝ := R.carrier</code> and so on</p>",
        "id": 202820486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793761
    },
    {
        "content": "<p>This is still just one type, we just don't know what type it is</p>",
        "id": 202820530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793792
    },
    {
        "content": "<p>Does it mean that coercions would be involved everytime we manipulate a real number?</p>",
        "id": 202820612,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593793827
    },
    {
        "content": "<p>how so?</p>",
        "id": 202820624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793838
    },
    {
        "content": "<p>no more than currently</p>",
        "id": 202820630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793842
    },
    {
        "content": "<p>Ok, then I really don't understand what you mean.</p>",
        "id": 202820639,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593793854
    },
    {
        "content": "<p>Since this <code>ℝ</code> type will be a complete ordered field you can write <code>2 : ℝ</code> as normal</p>",
        "id": 202820666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793872
    },
    {
        "content": "<p>the only thing that will be different is that you will not be able to prove theorems about <code>ℝ</code> by proving them about the underlying cauchy sequence representation</p>",
        "id": 202820797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793950
    },
    {
        "content": "<p>which we are already doing for the most part by making <code>real</code> irreducible</p>",
        "id": 202820839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593793987
    },
    {
        "content": "<p>Ok, sounds good, especially if it allows us to finally switch to Bourbaki reals <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 202820841,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593793988
    },
    {
        "content": "<p>The difference with lean 4's <code>constant</code> is that now there will be a literal meta theorem saying that you can swap out for dedekind cuts and nothing will break</p>",
        "id": 202820868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593794026
    },
    {
        "content": "<p>So this will make it easier to apply polynomial theorems to our favorite super fast polynomial implementation or whatever?</p>",
        "id": 202821166,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1593794276
    },
    {
        "content": "<p>Nice</p>",
        "id": 202821249,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1593794358
    },
    {
        "content": "<p>Ah, I hadn't thought of that. Indeed, if there are any buggy lean tactics that don't take the hint when they see <code>irreducible</code>, <code>constant</code> will be able to block them before they waste too much time</p>",
        "id": 202821496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593794587
    },
    {
        "content": "<p>At this point I should probably mention that <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> and I are at least <em>considering</em> introducing a simple module system for Lean 4 (where module = file, not functors involved). It would allow you to view a <code>def</code> inside a file as a <code>constant</code> outside of it (by default or not? All details TBD). The main motivation is to drastically speed up recompilation while <em>programming</em> in Lean, but as discussed, hiding implementations can be useful while proving as well.</p>",
        "id": 202821947,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593795017
    },
    {
        "content": "<p>I would recommend against tying file structure to this behavior. What about a <code>module</code> keyword that acts mostly like a section, but makes everything in the section <code>private</code>, then compile the module to a structure + an implementation of that structure as a <code>constant</code> + re-exporting the fields of that structure as theorems with the original chosen names</p>",
        "id": 202823234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593796233
    },
    {
        "content": "<p>(note in particular that this does not require any kernel changes)</p>",
        "id": 202823274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593796268
    },
    {
        "content": "<p>I would be very happy if we could have a feature like Coq modules but with all the mess going through a \"module compiler\" so that there is no kernel impact</p>",
        "id": 202823402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593796361
    },
    {
        "content": "<p>I'm not planning to change the kernel, this would be implemented in the import logic (which also means that we could drastically reduce the amount of data being imported). Autogenerating structures is not realistic when the majority of declarations in each file should be made opaque (at least for programming). Think of it as GHC's interface files produced for separate compilation.</p>",
        "id": 202823864,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593796817
    },
    {
        "content": "<p>maybe a special variant of <code>import</code> that triggers this behavior?</p>",
        "id": 202824184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797120
    },
    {
        "content": "<p>I think in mathlib this would be a small minority of files, you can't just seal all defs</p>",
        "id": 202824203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797150
    },
    {
        "content": "<p>+1 for not tying this to files but introducing something like a <code>module</code> keyword.</p>",
        "id": 202824305,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1593797182
    },
    {
        "content": "<p>Yes, the default <code>import</code> would most likely be unchanged</p>",
        "id": 202824339,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593797221
    },
    {
        "content": "<p>I will point out that Haskell also uses <code>module</code>, even though it's written once at the top of every file so it's easy to confuse with file based management</p>",
        "id": 202824356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797246
    },
    {
        "content": "<p>Alternatively, this could be tied to some attribute of the definition. I imagine that most of the defs you want to apply this to are what lean 3 would call <code>meta def</code>s</p>",
        "id": 202824449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797308
    },
    {
        "content": "<p>congratulations, they aren't meta anymore, but that doesn't change the fact that you have no intention to prove any property about them. Maybe make that explicit by using <code>constant</code></p>",
        "id": 202824500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797360
    },
    {
        "content": "<p>Do you have an example where you need a definition to be transparent in the file and opaque in the next file?</p>",
        "id": 202824601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593797422
    },
    {
        "content": "<p>You mean apart from <code>real</code> etc? Well, maybe you still need it to be transparent in the next file, but at some point you want to seal it and that will most likely be at a file boundary.</p>",
        "id": 202824895,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593797689
    },
    {
        "content": "<p>For programming you want every definition sealed unless you want it to be inlined or specialized</p>",
        "id": 202825041,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593797874
    },
    {
        "content": "<p>In the case of <code>real</code> there is a well defined module boundary. I'm wondering about the programming case</p>",
        "id": 202832410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593805357
    },
    {
        "content": "<p>Like you say, it seems like you want every definition sealed immediately, in which case there isn't really a reason to use <code>def</code> in the first place since <code>constant</code> already expresses this</p>",
        "id": 202832450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593805402
    },
    {
        "content": "<p>Do you think you could achieve your performance goals by using <code>constant</code> everywhere and not changing <code>import</code> for big programming developments?</p>",
        "id": 202832549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593805496
    },
    {
        "content": "<p>Files are a relatively natural boundary for limiting interprocedural optimizations, especially during development (you rarely want to build such high-level languages completely without optimizations). For example, \"Without -O, GHC does inlining within a module, but no cross-module inlining.\".</p>",
        "id": 202874671,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593870704
    },
    {
        "content": "<p>But I can see that the requirements for programming and proving might not be that similar here after all, so I'd be happy to see someone build a modules-as-structures system in Lean 4. That is more or less what we imagined a superior replacement for <code>parameter</code> could look like after all.</p>",
        "id": 202874862,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1593871004
    },
    {
        "content": "<p>Today, Kevin shared his thoughts about the traditional field axiom <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>x</mi><mn>0</mn></mfrac><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\"> \\frac x  0 = 0 </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>:<br>\n<a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>",
        "id": 202930392,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1593970091
    },
    {
        "content": "<p>Today we have <code>nnreal</code>s and can define <code>nnreal.sqrt</code> to be the \"mathematically correct\" square root. Then <code>a * b</code> will figure out <code>0 ≤ a * b</code> automatically.</p>",
        "id": 202931176,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1593971576
    },
    {
        "content": "<p>You can't subtract them though :-)</p>",
        "id": 202932167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593973212
    },
    {
        "content": "<p>For a while now <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> has been saying that formal theorem proving presents a unique opportunity for logicians and philosophers of mathematics.  Just like the early 1900s when logicians were starting to make formal vague terms like \"theorem\", \"proof\", and \"algorithm\", we have an opportunity to refine those ideas to fit practicing mathematics.  (The example Jeremy often used was that formally logicians say that a \"proof\" is a sequence or tree of statements with certain properties, but is that <em>really</em> how mathematicians think of a proof?)  I think this problem of partial functions is a great use case for Jeremy's proposed program.  When we say <code>a - b</code>, <code>a/b</code>, <code>sqrt a</code>, or the push forward of the probability measure <code>mu</code> under the map <code>f</code>, we have all these assumptions in mind.  Is there a formal logic (maybe very different from anything out there) that captures these statements and makes operations like rewriting seamless. Of course this new logic may only be an impossible pipe dream, but it doesn't seem beyond the realm of possibility.  (And if it does exist, it may have applications for programming language design as well, since dividing by zero or taking the 101th element of a list with only 100 elements can lead to bad errors in code.)</p>",
        "id": 202933039,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593974622
    },
    {
        "content": "<p>Also, if there is no such logic (or it is hard to find), because this is all related to the ambiguity of human language, then I hold out hope for soft tools like machine learning, especially neural based AI, which has shown itself to be good at working with incomplete and vague information.  An AI agent could realize that <code>a - b + b = a</code> is \"morally true\" (as I've heard mathematicians call it).  Then it could prove a lemma automatically by rewriting with that assumption, and then go back and \"dot all the i's and cross all the t's\" by proving the necessary assumptions needed to make the rewrites work.  Again, this may seem like a pipe dream, but I think the tools we have are making a lot of progress in that direction.</p>",
        "id": 202933461,
        "sender_full_name": "Jason Rute",
        "timestamp": 1593975242
    },
    {
        "content": "<p>A proof is a solution of a level in a computer game</p>",
        "id": 202934011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593976145
    },
    {
        "content": "<p>I agree with Kevin that this Lean's handling of division by zero isn't the most important issue facing formalized mathematics today, but mathematicians are right to show some concern. It would be disconcerting if it turned out that some important formalized theorem about perfectoid spaces turned out to be false when we change the value of 1/0. Right now, we don't have good ways of ensuring that won't happen, or even determining whether it is the case.</p>\n<p>There is a nice survey of logics for partial terms by Feferman: <a href=\"https://math.stanford.edu/~feferman/papers/definedness.pdf\">https://math.stanford.edu/~feferman/papers/definedness.pdf</a>. The best known implementation of a proof assistant that builds in partiality is Farmer's IMPS (<a href=\"https://link.springer.com/article/10.1007/BF00881906\">https://link.springer.com/article/10.1007/BF00881906</a>), but I can't speak for its usability.</p>\n<p>The two common ways of dealing partiality in a type theory involve either modifying the output type to take an undefined value (<code>option</code> or <code>roption</code>) or modifying the input type to restrict the valid inputs, with the condition bundled as a subtype or unbundled as a precondition. My preferred solution for division would be to have the fact that the denominator is nonzero is a precondition, one that is handled by automation so that we rarely think about it.</p>\n<p>It is sometimes not entirely clear what the mathematics should mean when we deal with partial functions. There are two ways of interpreting the statement \"f(x) -&gt; 0 as x -&gt; 0\" when f is partial, described here: <a href=\"https://math.stackexchange.com/questions/2883458/what-is-the-right-definition-of-the-limit-of-a-function/2883484#2883484\">https://math.stackexchange.com/questions/2883458/what-is-the-right-definition-of-the-limit-of-a-function/2883484#2883484</a>. A couple of years ago I generalized the <code>tendsto</code> relation to cover partial functions and multifunctions (<a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/partial.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/partial.lean</a>), in the hopes that this would be useful for set-valued analysis. But I never got back to it.</p>",
        "id": 202977289,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594034669
    },
    {
        "content": "<blockquote>\n<p>It would be disconcerting if it turned out that some important formalized theorem about perfectoid spaces turned out to be false when we change the value of 1/0. Right now, we don't have good ways of ensuring that won't happen, or even determining whether it is the case.</p>\n</blockquote>\n<p>Right now we're ok because I suspect that no theorem about perfectoid spaces will ever mention division. But for theorems about Banach spaces maybe life isn't so easy.</p>",
        "id": 202980163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594037179
    },
    {
        "content": "<p>If the theorem mentions division it's always going to be quite easy to prove the statement about partial division given the statement about Lean's division. Maybe not I guess if it mentions division somewhere deep down.</p>",
        "id": 202980966,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1594037803
    },
    {
        "content": "<p>If a theorem which mathematicians are interested in mentions division then what you're dividing by won't be allowed to be zero, either by theorem or by (possibly unwritten) assumption.</p>\n<p>\"Does there exists a real number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>r</mi><mo>=</mo><mn>0</mn><mo stretchy=\"false\">?</mo></mrow><annotation encoding=\"application/x-tex\">1/r=0?</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">?</span></span></span></span> is a good example. It's impossible to find a mathematician who will say \"yes\" to this, and they will have no complaints about the question being well-posed: we implicitly add the assumption that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">r\\not=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> when parsing.</p>",
        "id": 202981326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594038119
    },
    {
        "content": "<p>It's funny, right. Mathematicians have these promises that they will never do something wrong, hence you can swap out objects and replace them by canonically isomorphic ones...<br>\nBut if you do this with their field operation, all of a sudden they become very uneasy. It's an implementation detail, but we are getting very close to the boundary of where the \"promise\" still holds/works.</p>",
        "id": 202984390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594040123
    },
    {
        "content": "<blockquote>\n<p>The idiomatic way to do it is to allow garbage inputs like negative numbers into your square root function, and return garbage outputs. It is in the theorems where one puts the non-negativity hypotheses. </p>\n</blockquote>\n<p>Just out of curiosity, is the choice of garbage output unique (to make the function total)? Any particular reason to choose 0 except that it seems to be more \"neutral\" than other choices? When <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span> is available, should it be chosen because it's more \"extreme\" than zero?</p>\n<p>I asking this also because something inside me wishes the outputs of further operations on the garbage result are also garbage-ish. Maybe it's just part of the symptoms described in the last part of the post.</p>\n<p>The lesson learned here may be: one should not expect sanity from definitions (they should be allowed to be wild), instead the sanity lies in theorems and theorems only.</p>",
        "id": 202986440,
        "sender_full_name": "Utensil Song",
        "timestamp": 1594041178
    },
    {
        "content": "<p>I guess the rule of thumb is that the garbage output should make as many theorems still true without the condition that the input not be garbage as possible, to reduce the proof obligations on the user later.<br>\nFor the square root of negative reals for example you might want that</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">real</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sqrt</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sqrt</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">sqrt</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>this isn't true without some additional assumption, but I believe if you send negatives to zero then you only need to assume one of a or b is nonnegative, but if you use any other fixed number as garbage then you'll need to assume both a and b are nonnegative for this to hold.<br>\nThe square root function is also still continuous with this definition, which might be nice.</p>",
        "id": 202987211,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594041653
    },
    {
        "content": "<blockquote>\n<p>If a theorem which mathematicians are interested in mentions division then what you're dividing by won't be allowed to be zero, either by theorem or by (possibly unwritten) assumption.</p>\n</blockquote>\n<p>Exactly. So now you prove a theorem formally, and your mathematician friend wants to know: \"Why should I be interested in your theorem? I trust my own theorems because I know what they say. But I don't trust all your formal nonsense, especially when you tell me 1/0 = 0.\"</p>\n<p>Right now the best we can do for a formal sanity check is to find a formulation that doesn't mention division and then prove that it follows from your formal statement. But, as Chris says, when the theorem is built on top of definitions that use division all the way down, that's hard to do.</p>\n<p>To repeat: I don't think this is the most serious issue we are facing now. But it is a legitimate concern, and there should be better solutions.</p>",
        "id": 202996800,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594045742
    },
    {
        "content": "<p>But the definitions don't have to avoid division, they just need to not rely on division by zero</p>",
        "id": 202996923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594045802
    },
    {
        "content": "<p>Yes, but how can to determine that they don't?</p>",
        "id": 202997111,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594045903
    },
    {
        "content": "<p>by looking at them</p>",
        "id": 202997133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594045914
    },
    {
        "content": "<p>you have to do this anyway in order to verify the statement is what you expect</p>",
        "id": 202997196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594045930
    },
    {
        "content": "<p>Even where there are nontrivial modifications like <code>field</code>, you get a metatheorem like \"Let a Lean-field be a field with an operation <code>/'</code> that matches division away from zero and satisfies <code>a /' 0 = 0</code>. Then any theorem about Lean-fields using <code>/'</code> away from zero is also true of fields using division.\"</p>",
        "id": 202997543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046092
    },
    {
        "content": "<p>If sqrt(x) were defined to be sqrt(|x|) then <code>sqrt_mul</code> would be true unconditionally. I'm not the first person to observe this.</p>",
        "id": 202997566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594046103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/202997566\">said</a>:</p>\n<blockquote>\n<p>If sqrt(x) were defined to be sqrt(|x|) then <code>sqrt_mul</code> would be true unconditionally. I'm not the first person to observe this.</p>\n</blockquote>\n<p>I was thinking that when I wrote it, we did this for log right?</p>",
        "id": 202997662,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594046157
    },
    {
        "content": "<p>FWIW I like <code>sqrt x = 0</code> for negative <code>x</code> because that's the real part of the square root function</p>",
        "id": 202997854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046249
    },
    {
        "content": "<p>What does it mean to \"not rely on division by 0\"? If the definitions use our division, and our division takes a value when you divide by 0, the the definitions rely on division by 0. Some of the theorem <code>(x + y) / z</code> along the way do as well.</p>\n<p>Mathematicians can (in principle) say that division by 0 is undefined and that the theorems are nonetheless true with that understanding. That is patently false for some theorems in mathlib, and true for others. But how do you tell which is which?</p>",
        "id": 202998010,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594046316
    },
    {
        "content": "<p>Any assumption that uses division in a statement needs appropriate quantifier bounds to ensure that the value doesn't matter</p>",
        "id": 202998111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046368
    },
    {
        "content": "<p>that is enough to eliminate a large fraction of spurious uses</p>",
        "id": 202998139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046386
    },
    {
        "content": "<p>the use of theorems and proofs that use division by zero along the way doesn't matter, only whether the final theorem statement contains divisions not guarded by a quantifier bound</p>",
        "id": 202998344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046487
    },
    {
        "content": "<p>Kevin's example <code>\\exists x, 1/x = 0</code> is obviously violating this condition, it has a division and no quantifier bound saying <code>x != 0</code></p>",
        "id": 202998473,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046550
    },
    {
        "content": "<p>Something like <code>\\exists x &gt; 1, 1 / x = 0</code>, even if the <code>/</code> is Lean-division, is okay because the division occurs in a context where <code>x != 0</code> is provable</p>",
        "id": 202998625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046641
    },
    {
        "content": "<p>What does it mean to say a \"theorem about Lean-fields uses <code>/'</code> away from 0\", especially when there are definitions involved? You need some guarantee that when you unwrap all the definitions and quantifier bounds all the way down, you can prove that anything the division every gets applied to is nonzero. If you can do that, you may as well do an automatic translation to a version with a <code>/''</code> that has formal preconditions.</p>",
        "id": 202998832,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594046737
    },
    {
        "content": "<p>If this quantifier bound condition were all there were to it, it would not be difficult to write a program to analyze the statement and determine if the condition is satisfied (or at least, produce a bunch of proof obligations that imply that the statement is okay)</p>",
        "id": 202998940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046777
    },
    {
        "content": "<p>yes, just like that</p>",
        "id": 202998960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046785
    },
    {
        "content": "<p>It gets harder when you have definitions that legitimately use division by zero, like <code>field</code></p>",
        "id": 202999023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046824
    },
    {
        "content": "<p>here you have to track definedness conditions on the use of the new definition that imply that they are safe and propagate them (so other functions also become partial)</p>",
        "id": 202999090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046876
    },
    {
        "content": "<blockquote>\n<p>If you can do that, you may as well do an automatic translation to a version with a /'' that has formal preconditions.</p>\n</blockquote>\n<p>I'm not sure what this translation would be though</p>",
        "id": 202999217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594046937
    },
    {
        "content": "<p>Maybe we could use an attribute to flag such definitions?</p>",
        "id": 202999222,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594046939
    },
    {
        "content": "<p>It basically boils down to a definition that doesn't mean the same as what the mathematician thinks they mean</p>",
        "id": 202999404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047045
    },
    {
        "content": "<p>But I think we have bigger fish to fry in this arena, for example <code>0 &lt; 0.1</code> being false</p>",
        "id": 202999442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047070
    },
    {
        "content": "<p>Exactly. It would be nice to have automation that does it.  It is easy to do in simple cases. When I first proved the prime number theorem in Isabelle many years ago, it said \"pi n * log n / n --&gt; 1\". In the definition of the limit of a sequence, n could be 0. It is pretty obvious that this doesn't break anything; for example, you can substitute \"n+1\" for \"n\" and the problem goes away. But I think it is reasonable for a mathematician to complain that an entire analysis library is built on top of division, with no sort of guarantee that it is being used correctly.</p>",
        "id": 202999498,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594047111
    },
    {
        "content": "<p>You think / type faster than me. The \"Exactly\" referred to the statement that it would be nice if we could check all the implicit side conditions.</p>",
        "id": 202999640,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1594047182
    },
    {
        "content": "<p><code>0 &lt; 0.1</code> is false??? Is that because <code>0.1</code> is a natural number?</p>",
        "id": 202999737,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594047231
    },
    {
        "content": "<p>yes</p>",
        "id": 202999744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047238
    },
    {
        "content": "<p>Of course it is...</p>",
        "id": 202999750,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594047241
    },
    {
        "content": "<p>If it quacks like a duck...</p>",
        "id": 202999805,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594047254
    },
    {
        "content": "<p>I think you need to look at the problem modularly, where you say \"does <code>log</code> match what I think natural log is?\" If you can do that for all the definitions, then you will have a good understanding of the visible theorem statement, and all you have to worry about is the explicit division in PNT</p>",
        "id": 202999815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047261
    },
    {
        "content": "<p>That is, for each formal notion you work out what its mathematical meaning is, without presupposing that it is exactly the same as the math notion</p>",
        "id": 202999908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047317
    },
    {
        "content": "<p>I often have to do this anyway if the formal statement uses some unfamiliar terminology</p>",
        "id": 202999978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047359
    },
    {
        "content": "<p>like I would probably look up <code>--&gt;</code> in that isabelle statement</p>",
        "id": 203000062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047391
    },
    {
        "content": "<p>I'm sure it means limit, but is it a limit over natural numbers? Real numbers? How does it handle partiality? These questions must be answered by looking at the formal definition</p>",
        "id": 203000163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047451
    },
    {
        "content": "<p>I don't think an automated tool can solve this problem because it is fundamentally about the difference between a formal object and an informal object (the meaning in the mathematician's head)</p>",
        "id": 203000413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594047576
    },
    {
        "content": "<p>Given that this topic is about my blog posts, I may as well give you some stats. In the same week that Rob announced that there had been as much mathlib activity in 2020 as there had been in the whole of 2019 (I forget how he measured it, perhaps commits or lines of code), I made it to 42000 views on the blog, beating the 41000 views I got in all of 2019. I'll make it to 50K within the next few days I think. The general pattern seems to be that if I post something which either hacker news or reddit r/math or twitter likes, then I get 1000+ views per day for the next couple of days, e.g. the \"mathematics in type theory\" post from two weeks ago got 1000+ views for three days from Twitter and then 2000+ views for two days, when hacker news got excited about it. These sorts of posts seem to be the most popular ones -- where a general computer scientist or mathematician who doesn't know anything about Lean can at least read and understand the post and think \"hmm, I learnt something about how doing mathematics in type theory / Lean works from reading this\". </p>\n<p>I will repeat the offer I occasionally make -- if there is anyone out there who thinks they have something which will appeal to mathematics undergraduates who perhaps don't know anything about Lean (these are usually the people I'm thinking about when I write) or perhaps to a more general audience (e.g. people who read hacker news or r/math) then they should feel free to get in touch and propose writing a guest post. So far Chris Hughes is the only person who did this. Ideally the post will have some relation to mathematics, and will be more accurate than the kind of poorly researched nonsense I churn out.</p>",
        "id": 203013765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594054332
    },
    {
        "content": "<p>Even more accurate than that? You're setting the bar too high.</p>",
        "id": 203026464,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1594061333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/XenaProject.20blog.20posts/near/202999442\">said</a>:</p>\n<blockquote>\n<p>But I think we have bigger fish to fry in this arena, for example <code>0 &lt; 0.1</code> being false</p>\n</blockquote>\n<p>I'm in the mood for fish bbq: <a href=\"https://github.com/leanprover-community/lean/issues/381\">lean#381</a></p>",
        "id": 203031613,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594064287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I don't think we got to a consensus whether this change is desirable.</p>",
        "id": 203031863,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1594064483
    },
    {
        "content": "<p>To be clear, this is more of an RFC.  I'm also not sure if it's a good idea, particularly given how unlikely it would be to have this in Lean 4.</p>",
        "id": 203031958,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594064531
    },
    {
        "content": "<p>See discussion below this post for the discussion about this topic: <a href=\"#narrow/stream/113488-general/topic/37/near/202221745\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/37/near/202221745</a></p>",
        "id": 203032049,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1594064596
    },
    {
        "content": "<p>I propose a truce between the \"it's obvious from the lemma statement whether division by 0 can arise\" camp and the \"it's subtle and mathematicians have reasons to worry\" camp. Since the proof of the pudding is in the eating, one should just have a division operator that carries a proof in addition to the current one and, for those statements where we care/worry about this, prove the lemma with that operator, reusing the lemma proved using the Lean division. That proof should be easy/trivial in most cases, notably those that have a guard. That's what I'd do if I were to base a math textbook on a Lean formalization.</p>",
        "id": 203034913,
        "sender_full_name": "Jasmin Blanchette",
        "timestamp": 1594066161
    },
    {
        "content": "<p>It would certainly make some mathematicians happy</p>",
        "id": 203035308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594066407
    },
    {
        "content": "<p>I'm always surprised that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">x/0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mord\">/</span><span class=\"mord\">0</span></span></span></span> is such a contentious topic.  There is one good and canonical choice, namely the one which makes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mo>⋅</mo></mrow><annotation encoding=\"application/x-tex\">1/\\cdot</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord\">⋅</span></span></span></span> a pseudo-inverse.  Extending structures and operations to have nicer properties is so basic it borders on being invisible.  Who would object to prove a property of integers by embedding them into the real numbers, even though it extends the division operation?  How is it any different to embed fields into simple meadows?  Meanwhile there are multiple reasonable ways to define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>0</mn><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">0^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span>, or what about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\log(-1)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 203037473,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594067658
    },
    {
        "content": "<p>What's a simple meadow?</p>",
        "id": 203039664,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1594068961
    },
    {
        "content": "<p>Found the <a href=\"https://math.stackexchange.com/questions/1186171/the-prime-meadow-of-a-meadow\">definition</a></p>",
        "id": 203040212,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1594069317
    },
    {
        "content": "<p>Meadow are like field if you replace the axioms for division by being a pseudo-inverse (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mi mathvariant=\"normal\">/</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">(x/y)y = x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>).  Then they are a variety, in particular the smallest variety containing the fields.  (Every meadow is a direct product of fields.)</p>",
        "id": 203040522,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594069486
    },
    {
        "content": "<p>Funnily enough, I first heard of meadows before I got involved with proof assistants.  But now after I am looking again at the paper that introduced them, I have to realize that they were motivated by formalization.</p>",
        "id": 203040805,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1594069664
    },
    {
        "content": "<p>The whole 1/0 topic is silly and the reason I wrote the blog post was precisely because mathematicians were asking about it on Twitter and I thought I should at least try and put down some coherent thoughts into one place so that I can refer people to it later. But now I'm getting people saying to me that the systems should adapt and make it work the way mathematicians are used to, and just do the type theory way behind the scenes</p>",
        "id": 203041709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594070186
    },
    {
        "content": "<p>The axiom reminds me a lot of <a href=\"https://en.wikipedia.org/wiki/Von_Neumann_regular_ring\">von Neumann regular rings</a>, where for every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> there is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x=xax</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">x</span></span></span></span>.  It's not just a von Neumann regular ring, though, since a meadow has an involutive map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">x \\mapsto x^{-1}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> that gives the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>.</p>",
        "id": 203041825,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594070276
    },
    {
        "content": "<p>It seems like a classic bikeshedding problem. Everyone understands the question so you get an outsized number of complaints/suggestions</p>",
        "id": 203042075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594070389
    },
    {
        "content": "<p>(Though it looks like commutative von Neumann regular rings have such an involution, so I guess I'm not sure whether meadows are any different from commutative von Neumann regular rings.  I like the name, though.)</p>",
        "id": 203042215,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594070472
    },
    {
        "content": "<p>(By the way, if every Xena post generates this much discussion, one Zulip topic may not be enough)</p>",
        "id": 203042307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1594070526
    },
    {
        "content": "<p>This one is now trending on Hacker news so I'm getting 500 views an hour.</p>",
        "id": 203045358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594072512
    },
    {
        "content": "<p>And it's about such a ridiculous subject!</p>",
        "id": 203045365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594072522
    },
    {
        "content": "<p>(Here's a fun fact to justify the color of Lean's bikeshed.  The class of <a href=\"https://en.wikipedia.org/wiki/ELEMENTARY\">elementary recursive functions</a> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}\\to\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> can be given as expressions involving only the variable, <code>nat.add</code>, <code>nat.sub</code>, <code>nat.div</code>, and <code>nat.pow</code> as Lean defines them.)</p>",
        "id": 203046144,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594073019
    },
    {
        "content": "<p>That is a good point about bike shedding.  I’ll try to be more careful in the future.</p>",
        "id": 203057722,
        "sender_full_name": "Jason Rute",
        "timestamp": 1594083136
    },
    {
        "content": "<p>I was just experimenting with a way to hide domain hypotheses inside equations.  I'm sure others have tried something like this before.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">safe_minus</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span>\n\n<span class=\"n\">reserve</span> <span class=\"kn\">infixl</span> <span class=\"bp\">`</span> <span class=\"bp\">-!</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">65</span>\n\n<span class=\"kn\">notation</span> <span class=\"n\">x</span> <span class=\"bp\">`</span> <span class=\"bp\">-!</span> <span class=\"bp\">`</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">safe_minus</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">linarith</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">-!</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>   <span class=\"c1\">-- Lean can figure out this is OK</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">dunfold</span> <span class=\"n\">safe_minus</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">-!</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>   <span class=\"c1\">-- if you remove the h hypothesis, Lean will complain</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_add_cancel</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 203222590,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1594172007
    },
    {
        "content": "<p>Yup, it's really cool when it works, but when it breaks it's a pain (at least in lean).<br>\nI do think there is potential for something like this. However, I have don't have a good idea how to treat <code>-!</code> when <code>linarith</code> fails. Is the fallback scenario simply that the user must write</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">foobar</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"k\">proof</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">safe_sub_add_cancel</span><span class=\"o\">,</span> <span class=\"c1\">-- now linarith can figure it out</span>\n</code></pre></div>",
        "id": 203230964,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1594183457
    }
]