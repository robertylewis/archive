[
    {
        "content": "<p>Hi all,</p>\n<p>Noob question: I am trying to prove some elementary results in number theory to get more practice with Lean proof writing. I feel that some generic tactic should kill this MWE, but I can't seem to find it:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">blah</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]:</span>\n<span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">g</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">true</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Thanks in advance for any help...</p>",
        "id": 202693896,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1593699283
    },
    {
        "content": "<p><code>congr, ext, simp</code></p>",
        "id": 202695480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593700018
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254058\">@Marc Masdeu</span> Hi, welcome back. (Have you seen <a href=\"https://leanprover-community.github.io/lftcm2020/\">https://leanprover-community.github.io/lftcm2020/</a>)<br>\nOoh, Mario is faster with answering the actual question <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 202695519,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593700043
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"254058\">Marc Masdeu</span> Hi, welcome back. (Have you seen <a href=\"https://leanprover-community.github.io/lftcm2020/\">https://leanprover-community.github.io/lftcm2020/</a>)</p>\n</blockquote>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, I've been following everything Lean, just not posting to here... I know about the workshop, but sadly I'll be \"away\" next week...</p>",
        "id": 202696382,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1593700418
    },
    {
        "content": "<p>Ok, no worries!</p>",
        "id": 202696514,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593700460
    },
    {
        "content": "<p>OK, turns out that the MWE I constructed was too M (but thanks <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ! I did learn about congr!). Here's an updated one, hopefully it is enough now:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">some_subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">blah2</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]:</span>\n<span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">some_subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">some_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)),</span> <span class=\"err\">↑</span><span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202698689,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1593701415
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_congr</span> <span class=\"c1\">--?</span>\n</code></pre></div>",
        "id": 202699051,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593701580
    },
    {
        "content": "<p>It complains with</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">apply</span> <span class=\"n\">tactic</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">some_subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">some_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)),</span> <span class=\"err\">↑</span><span class=\"n\">g</span>\n<span class=\"k\">with</span>\n  <span class=\"err\">?</span><span class=\"n\">m_4</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"err\">?</span><span class=\"n\">m_5</span> <span class=\"bp\">=</span> <span class=\"err\">?</span><span class=\"n\">m_6</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"err\">?</span><span class=\"n\">m_7</span>\n</code></pre></div>",
        "id": 202699543,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1593701834
    },
    {
        "content": "<p>Aah, of course</p>",
        "id": 202699597,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593701872
    },
    {
        "content": "<p>The rhs is over some subgroup.</p>",
        "id": 202699620,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593701881
    },
    {
        "content": "<p><code>rw finset.prod_subtype</code>?</p>",
        "id": 202699676,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593701888
    },
    {
        "content": "<p>If all else fails, there is <code>finset.prod_bij</code> but I would try to avoid that.</p>",
        "id": 202699739,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593701922
    },
    {
        "content": "<p><code>finset.prod_subtype</code> does not seem to exists...</p>",
        "id": 202699968,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1593702020
    },
    {
        "content": "<p><code>import data.fintype.card</code>? I think</p>",
        "id": 202700011,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593702038
    },
    {
        "content": "<p>This has worked:</p>\n<div class=\"codehilite\"><pre><span></span><code>    <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_subtype</span><span class=\"o\">,</span>\n    <span class=\"n\">tauto</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>Leaving me with no idea of what's going on, of course...</p>",
        "id": 202700424,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1593702242
    },
    {
        "content": "<p><code>prod_subtype</code> is missing</p>",
        "id": 202700668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593702353
    },
    {
        "content": "<p>oops, misread Johan's suggestion. This proof might be a little clearer:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">blah2</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]:</span>\n<span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">some_subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">some_subgroup</span> <span class=\"n\">G</span><span class=\"o\">)),</span> <span class=\"err\">↑</span><span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_subtype</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202701438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593702699
    },
    {
        "content": "<p>Unfortunately the unification problem leaves <code>has_coe_t_aux.coe</code> in the term, and <code>simp</code> doesn't know how to simplify it, so we have to finish with <code>iff.rfl</code> instead</p>",
        "id": 202701636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1593702788
    },
    {
        "content": "<p>Here is what I have managed to prove: given a finite commutative group G, the product of all its elements equals the product of its elements of order 2. This could be seen as some sort of generalization of Wilson's theorem on the factorial of p-1 modulo p.</p>\n<p>Now I know that this is terrible coding style, especially the proof of <code>prod_all_eq_prod_two_torsion</code>. I would appreciate a constructive critique of it. I am not looking for anything mathlib-ready at all, and in fact I'm happy with expensive tactics (to prove mathematically obvious statements) as long as it stays somewhat readable...</p>\n<p>Thanks!</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">prod_finset_distinct_inv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">case_strong_induction_on</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">a_notin_s</span> <span class=\"n\">H</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n<span class=\"n\">specialize</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">erase_subset</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n<span class=\"k\">have</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">apply</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simpa</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">clarify</span><span class=\"o\">,</span>\n    <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">x_not_ainv</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">ne_of_mem_erase</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">by_contradiction</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_of_mem</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_erase</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">},</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_insert</span> <span class=\"n\">a_notin_s</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"n\">hkey</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mul_eq_one_iff_inv_eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">hkey</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">ainv_notin_s1</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∉</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">not_mem_erase</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ainv_in_s</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"k\">have</span> <span class=\"n\">ainv_in_s1</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_self</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n    <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_insert_of_ne</span> <span class=\"n\">ainv_in_s1</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h2</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_self</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">insert_erase</span> <span class=\"n\">ainv_in_s</span><span class=\"o\">,</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_insert</span> <span class=\"n\">ainv_notin_s1</span><span class=\"o\">,</span><span class=\"n\">r</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mul_one</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span>\n  <span class=\"o\">},</span>\n<span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">tidy</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_mul_mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"n\">mul_one</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">tidy</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">mul_inv_eq_one</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"n\">inv_eq_of_mul_eq_one</span> <span class=\"n\">ha</span><span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">prod_all_eq_prod_two_torsion</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]:</span>\n<span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">hdisj</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n        <span class=\"n\">cases</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n        <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n        <span class=\"n\">suffices</span> <span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"n\">hA</span><span class=\"o\">)),</span>\n        <span class=\"n\">clear</span> <span class=\"n\">hA</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">mul_eq_one_iff_eq_inv</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n        <span class=\"n\">assumption</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">g</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">apply</span> <span class=\"n\">prod_finset_distinct_inv</span><span class=\"bp\">;</span>\n        <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n            <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span>\n        <span class=\"c1\">--simp [finset.prod_union],</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_union</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">congr</span><span class=\"o\">,</span>\n            <span class=\"n\">ext1</span><span class=\"o\">,</span>\n            <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">coe_inj</span><span class=\"o\">],</span>\n            <span class=\"n\">safe</span><span class=\"o\">,</span>\n            <span class=\"n\">suffices</span> <span class=\"n\">hh</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n            <span class=\"k\">have</span> <span class=\"n\">a2</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">eq_inv_iff_mul_eq_one</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h_1</span><span class=\"o\">,</span>\n            <span class=\"n\">tauto</span><span class=\"o\">,</span>\n        <span class=\"o\">},</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">disjoint_iff_disjoint_coe</span><span class=\"o\">],</span>\n            <span class=\"n\">exact</span> <span class=\"n\">hdisj</span><span class=\"o\">,</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_subtype</span><span class=\"o\">,</span>\n        <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202718881,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1593710754
    },
    {
        "content": "<p>Its a nice result, I'd say we should have (some version) it in mathlib!<br>\nI made some comments inline: it looks pretty good to me, maybe more lemmas and less long proofs would be more manageable though, like for the last statement you could have a lemma that<br>\nprod of elements of G is prod of the two torsion times prod of things not their own inverse.<br>\nthen a lemma that the prod of things that are not their own inverse of any group is one, all as separate lemmas which are combined at the end (basically all of the have's in the last proof could be lemmas)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n<span class=\"c\">/-</span><span class=\"cm\"> General comments</span>\n<span class=\"cm\"> 1. You can add @[to_additive] to generate additive versions of these lemmas if you like</span>\n<span class=\"cm\"> 2. you use tactics like clarify, finish, safe, a lot, these things can be a little slow, but they</span>\n<span class=\"cm\">    are convenient, so might be best to separate out some of the times they are used as separate lemmas</span>\n<span class=\"cm\">    whose proof is just by finish or whatever, so that they don&#39;t get re-run all the time -/</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">profiler</span> <span class=\"n\">true</span> <span class=\"c1\">-- you can use this too see time spent on proofs</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">prod_finset_distinct_inv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">case_strong_induction_on</span> <span class=\"n\">s</span><span class=\"o\">,</span>  <span class=\"k\">by</span> <span class=\"n\">tauto</span><span class=\"o\">,</span>\n<span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">a_notin_s</span> <span class=\"n\">H</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n<span class=\"n\">specialize</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">erase_subset</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n<span class=\"k\">have</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">apply</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simpa</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"k\">begin</span> <span class=\"n\">finish</span><span class=\"o\">,</span> <span class=\"kn\">end</span><span class=\"o\">,</span> <span class=\"c1\">-- this takes ages</span>\n    <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_insert_of_ne</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_of_mem</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_erase</span> <span class=\"n\">h</span><span class=\"o\">)))</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- replaced finish with an explicit proof,</span>\n    <span class=\"n\">by_contradiction</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hh</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">ne_of_mem_erase</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- replaced finish with an explicit proof and don&#39;t name a short term that is only used once now</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_of_mem</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_erase</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">},</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_insert</span> <span class=\"n\">a_notin_s</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"n\">hkey</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mul_eq_one_iff_inv_eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">hkey</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">ainv_notin_s1</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∉</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">erase</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">not_mem_erase</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ainv_in_s</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"k\">have</span> <span class=\"n\">ainv_in_s1</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_self</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n    <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_insert_of_ne</span> <span class=\"n\">ainv_in_s1</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"c1\">-- by exact can almost always be removed!</span>\n    <span class=\"c1\">-- as it is just openening tactic mode then returning to term mode</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h2</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_self</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">insert_erase</span> <span class=\"n\">ainv_in_s</span><span class=\"o\">,</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_insert</span> <span class=\"n\">ainv_notin_s1</span><span class=\"o\">,</span><span class=\"n\">r</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mul_one</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span>\n  <span class=\"o\">},</span>\n<span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">},</span>\n  <span class=\"n\">one_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"c1\">-- use tidy? and tidy will tell you what it did in this case it only did dsimp at *, and we can just change it to dsimp</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_mul_mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mul_one</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"c1\">-- exact instead of refine</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">mul_inv_eq_one</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"n\">inv_eq_of_mul_eq_one</span> <span class=\"n\">ha</span><span class=\"o\">}</span> <span class=\"c1\">--same with tidy</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">prod_all_eq_prod_two_torsion</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]:</span>\n<span class=\"err\">∏</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"err\">∏</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"c1\">-- don&#39;t need brackets</span>\n<span class=\"k\">begin</span>\n    <span class=\"k\">have</span> <span class=\"n\">hdisj</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n        <span class=\"n\">cases</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n        <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">assumption</span><span class=\"o\">,</span>\n        <span class=\"n\">suffices</span> <span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"n\">hA</span><span class=\"o\">)),</span>\n        <span class=\"n\">clear</span> <span class=\"n\">hA</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n        <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">mul_eq_one_iff_eq_inv</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"c1\">-- simpa .. using instead of simp .. at .., assumption</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">g</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">apply</span> <span class=\"n\">prod_finset_distinct_inv</span><span class=\"bp\">;</span>\n        <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">two_torsion_subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n            <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span>\n        <span class=\"c1\">--simp [finset.prod_union],</span>\n        <span class=\"c1\">-- using squeeze_simp we see that simp only used one lemma here, which was ne.def</span>\n        <span class=\"c1\">-- didn&#39;t seem like this was really changing anything so remove it!</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_union</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">congr</span><span class=\"o\">,</span>\n            <span class=\"n\">ext1</span><span class=\"o\">,</span>\n            <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_iff</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">ne</span><span class=\"bp\">.</span><span class=\"n\">def</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_union</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_set_of_eq</span><span class=\"o\">],</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">two_torsion_subgroup</span><span class=\"o\">,</span> <span class=\"n\">eq_inv_iff_mul_eq_one</span><span class=\"o\">],</span> <span class=\"c1\">--neater proof</span>\n            <span class=\"n\">exact</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">em</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n        <span class=\"o\">},</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">disjoint_iff_disjoint_coe</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">coe_to_finset</span><span class=\"o\">],</span>\n            <span class=\"c1\">-- simp then exact (hypothesis) can be written as simpa</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"c1\">-- once again simp wasnt doing much to most goals</span>\n        <span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">prod_subtype</span><span class=\"o\">,</span>\n        <span class=\"n\">finish</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202742147,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1593722519
    },
    {
        "content": "<p>Probably relevant: <code>prod_involution</code></p>",
        "id": 202742425,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593722727
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> for the review! I have incorporated your suggestions, although I see no way of coming up with this</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_insert_of_ne</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_of_mem</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_erase</span> <span class=\"n\">h</span><span class=\"o\">)))</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>on my own without spending half an hour trying different things. Would be nice if the <code>finish</code> tactic gave something back as a hint!</p>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> : I was aware of <code>prod_involution</code> (this is the one that wilson's theorem uses, right?), but wanted to prove the version that I needed using tactics.</p>\n<p>Next step (we have a \"summer project\" with <span class=\"user-mention\" data-user-id=\"315546\">@Xavier Xarles</span>) will be to prove that the product of all the elements of a finite elementary abelian 2-group of order &gt; 2 is 1...</p>",
        "id": 202789566,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1593772546
    },
    {
        "content": "<p>To expand on Johan's point, applying <code>prod_involution</code> reduces the problem to four much easier sorries.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">big_operators</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">prod_finset_distinct_inv</span>\n<span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">hs1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hs2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"err\">∏</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">prod_involution</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">mul_inv_self</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hs2</span><span class=\"o\">,</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hs1</span><span class=\"o\">,</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202805882,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1593784451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254058\">Marc Masdeu</span> <a href=\"#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/202789566\">said</a>:</p>\n<blockquote>\n<p>Would be nice if the <code>finish</code> tactic gave something back as a hint!</p>\n</blockquote>\n<p>I asked about this once and was told more or less that the output would be unreadable and no quicker than just running finish again unfortunately: <a href=\"https://github.com/leanprover-community/mathlib/issues/1451#issuecomment-533151071\">https://github.com/leanprover-community/mathlib/issues/1451#issuecomment-533151071</a></p>",
        "id": 203070357,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594103015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/202805882\">said</a>:</p>\n<blockquote>\n<p>To expand on Johan's point, applying <code>prod_involution</code> reduces the problem to four much easier sorries.</p>\n</blockquote>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> , we knew about this but it seemed like killing flies with cannons, so we set to prove directly what we exactly wanted. But in the long run, I agree your approach is the right one.</p>",
        "id": 203485008,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1594372240
    },
    {
        "content": "<p>And now I can't even start the next lemma:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- given G two torsion and 1 ≠ g ∈ G, there is H &lt; G of index 2 with g ∉ H</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">element_avoidance</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">):</span>\n <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∉</span> <span class=\"n\">H</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">H</span> <span class=\"err\">∪</span> <span class=\"o\">(</span><span class=\"n\">left_coset</span> <span class=\"n\">g</span> <span class=\"n\">H</span><span class=\"o\">)):=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">case_strong_induction_on</span> <span class=\"o\">(</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">G</span><span class=\"o\">),</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>I want to do a proof by induction on the size of G, but it complains at the first step. I can't quite make sense of the error. In trying to debug what was going on, I went for a much stupider lemma, which I can't do either!</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">stupid</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">):</span>\n <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span>  <span class=\"n\">H</span> <span class=\"bp\">=</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">use</span> <span class=\"err\">↑</span><span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"c1\">-- Complains!</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 203485263,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1594372426
    },
    {
        "content": "<p>One way to get <code>G</code> as a subgroup of itself is to think of the ordering on subgroups by inclusion, <code>G</code> is then tthe maximal, or top element, so lean understands the symbol <code>\\top</code> for <code>G</code> as a sub of itself.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">stupid</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">):</span>\n <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span>  <span class=\"n\">H</span> <span class=\"bp\">=</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">use</span> <span class=\"err\">⊤</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 203488036,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594374357
    },
    {
        "content": "<p>Also, be cautious using the arrow directly, if you want to coerce something try <code>(thing : Type)</code> to tell lean which type to coerce it to, lean will print the up arrow but it can be underdetermined what you want the arrow to mean so just putting the type you want can save headaches.</p>",
        "id": 203488304,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594374542
    },
    {
        "content": "<p>Yes but isn't this like cheating? I would expect that there would be some kind of coertion mechanism that would work in this case. In particular, <code>use (G : subgroup G)</code> is more like what I'd like to work, and it doesn't. Recall that I want to really do the non-stupid lemma by induction...</p>",
        "id": 203488494,
        "sender_full_name": "Marc Masdeu",
        "timestamp": 1594374654
    },
    {
        "content": "<p>As for your first question lean gets a bit confused because it doesn't see the cardinality of <code>G</code>, or even <code>G</code> really in your goal, maybe its possible to make it work, but it seems less hassle to set this up more explicitly as a statement parameterised by the caridinality of the group</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">element_avoidance_aux</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">G</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∉</span> <span class=\"n\">H</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">H</span> <span class=\"err\">∪</span> <span class=\"o\">(</span><span class=\"n\">left_coset</span> <span class=\"n\">g</span> <span class=\"n\">H</span><span class=\"o\">)):=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">case_strong_induction_on</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>your original statement is then obtained as <code>element_avoidance_aux (rfl _)</code> or something like that.</p>",
        "id": 203488752,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594374844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254058\">Marc Masdeu</span> <a href=\"#narrow/stream/113489-new-members/topic/Frustration.20with.20finset/near/203488494\">said</a>:</p>\n<blockquote>\n<p>Yes but isn't this like cheating? I would expect that there would be some kind of coertion mechanism that would work in this case. In particular, <code>use (G : subgroup G)</code> is more like what I'd like to work, and it doesn't. Recall that I want to really do the non-stupid lemma by induction...</p>\n</blockquote>\n<p>I agree some automatic coercion would be nice, I'm just not sure how the setup would go. It doesn't seem to me to fit the coercion model: <code>G</code> is a type and you can't make a coercion from any random type to <code>subgroup G</code>, only from <code>G</code> itself.</p>\n<p>Top is a bit weird to look at at first, but its short to type, and you get all the lemmas about order (every subgroup is contained in top, nothing contains top, etc for free.</p>",
        "id": 203489157,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594375166
    },
    {
        "content": "<p>I was confused but: Ohhh I get it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span></span></span></span> is index 2 only in the 2-torsion.</p>",
        "id": 203491429,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594376815
    },
    {
        "content": "<p>Coercing G into subgroup G is a dependent coercion which I don't think is possible</p>",
        "id": 203509774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1594389693
    }
]